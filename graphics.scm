(void)

(define (count-channels evts num-channels max-channels)
  (cond ((null? evts)
         max-channels)
        ((eq? (car evts) 'noteon)
         (count-channels (cdr evts)
                         (add1 num-channels)
                         (max (add1 num-channels) max-channels)))
        ((eq? (car evts) 'noteoff)
         (count-channels (cdr evts)
                         (sub1 num-channels)
                         max-channels))))

(define white (sdl2:make-color 255 255 255))
(define black (sdl2:make-color 0 0 0))
(define red (sdl2:make-color 255 0 0))

(define midi-time -1)
(printf "MIDI tracks: ~S~%" (map car midi))
(define track (alist-ref "input" midi equal?))

(define num-channels (count-channels (map cadr track) 0 0))
(printf "Allocating ~A channels for track.~%" num-channels)
(define-record channel env osc)
(define channels (make-vector num-channels))
(do ((i 0 (add1 i)))
    ((= i num-channels))
  (vector-set! channels i
               (make-channel (envelope~ 0.01 1)
                             (triangle~ 0))))
(define next-channel 0)

(define metro-tempo (/ us/qnote 1000000))
(printf "~A seconds per note~%" metro-tempo)
(define metro-t (- metro-tempo 1))
(define metro (make-channel (envelope~ 0.01 0.25)
                            (sin~ 0)))

(define dspbuf (make-f32vector 512 0 #t #t))

(define (dac~)
  (+ (* 0.3
        ((channel-env metro))
        ((channel-osc metro)))
     (let lp ((i 0) (sample 0))
       (if (= i num-channels)
           sample
           (let ((chan (vector-ref channels i)))
             (lp (add1 i)
                 (+ sample (* (/ 1 num-channels)
                              ((channel-env chan))
                              ((channel-osc chan))))))))))


(define rect (sdl2:make-rect 0 0 10 10))
(define *scale* 10)

(define (blink-on-note)
  (let* ((evt (car track))
         (evt-dt (car evt))
         (type (cadr evt))
         (data (cddr evt)))
    (when (and (>= midi-time evt-dt))
      (when (eq? type 'noteon)
        (print "playing on channel " next-channel)
        (set! *scale* 10)
        (let ((chan (vector-ref channels next-channel)))
          ((channel-osc chan) 'freq (midi->freq (car data)))
          ((channel-env chan) 'reset))
        (set! next-channel (add1 next-channel))
        )
      (when (eq? type 'noteoff)
        (set! next-channel (sub1 next-channel)))
      (set! midi-time 0)
      (set! track (cdr track))
      (unless (null? track) (blink-on-note)))))

(define *input-track* '())
(define *input-t* 0)

(define tolerence-perfect (/ metro-tempo 32))
(define tolerence-good (/ metro-tempo 16))
(define tolerence-bad (/ metro-tempo 8))

(define (register-input)
  (push! *input-t* *input-track*)
  (set! *input-t* 0)
  (let* ((next-event (car track))
         (next-dt (car next-event))
         (diff (- next-dt midi-time)))
    (cond ((= midi-time 0)
           (print "SUPER PERFECT"))
          ((or (> tolerence-perfect midi-time)
               (> tolerence-perfect diff))
           (print "PERFECT"))
          ((or (> tolerence-good midi-time)
               (> tolerence-good diff))
           (print "GOOD"))
          ((or (> tolerence-bad midi-time)
               (> tolerence-bad diff))
           (print "BAD"))
          (else (print "MISSED")))))


(define (handle-event ev)
  (cond ((and (eq? (sdl2:event-type ev) 'key-down)
              (eq? (sdl2:keyboard-event-scancode ev)
                   'space))
         (register-input)))
  )

(define (show-frame)
  (unless (null? track)
    (blink-on-note))
  
  (when (null? track)
    (print (reverse *input-track*)))
  
  (set! *input-t* (+ *input-t* dt))
  (set! metro-t (+ metro-t dt))
  (when (>= metro-t metro-tempo)
    ((channel-env metro) 'reset)
    ((channel-osc metro) 'freq 437)
    (set! metro-t 0))

  (set! (sdl2:render-draw-color render) white)
  (sdl2:render-clear! render)

  (set! (sdl2:render-draw-color render) red)
  (set! (sdl2:render-scale render) (list *scale* *scale*))
  (sdl2:render-fill-rect! render rect)
  (set! (sdl2:render-scale render) (list 1 1))

  (set! midi-time (+ midi-time  dt))
  (set! *scale* (max 0 (- *scale* (* dt 5))))

  (let* ((avail (pa:stream-write-available))
         (len (min avail 512)))
    (when (> len 512) (print len))
    (unless (zero? len)
      (fill-buf! dspbuf len)
      (pa:write-stream! dspbuf len)))
)